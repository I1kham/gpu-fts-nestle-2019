<html>
<head>
	<title>GUI Tutorial01</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	
	<style>
	body { background-color: #666; color:#fff; }
	.bottone { display:inline-block; border:solid 2px #000; border-radius:5px; background-color:#000; color:#fff; text-align:center; padding:10px; cursor:pointer; }
	</style>
</head>

<body onLoad="rheaBootstrap()">
<p>TUTORIAL 01</p>

<div style="border:solid 1px #000; padding:5px; margin-bottom:10px; background-color:#88ff88; color:#000">
	Si consiglia vivamente di aprire la CONSOLE del broswer (premi F12 su chrome e/o Firefox) in modo da vedere i messaggi di debug/console
	che questa app produce come risposta ai vari eventi spontanei inviati da SMU
</div>

<div id="divBottoniera">
	<div class="bottone" onclick="startSelection(2)">SELEZIONE 2</div>
	<div class="bottone" onclick="startSelection(13)">SELEZIONE 13</div>
	<div class="bottone" onclick="getCPUModelAndVer()">GET CPU MODEL AND VERSION</div>
	
	<!-- questo è il nuovo bottone che fa partire il comando "startErogBicchiere", vedi funzione startErogazioneBicchiere() più sotto -->
	<div class="bottone" onclick="startErogazioneBicchiere()">START EROGAZIONE BICCHIERE</div>
</div>

<div id="divPleaseWait" style="display:none">
	<img src="img/animationRound.gif">
</div>


<script src="js/rheaBootstrap.js"></script>
<script language="javascript">
function onRheaBootstrapFinished() 
{
	//Entry point dell'applicazione. Questa fn viene chiamata non appena la pagina html finisce di caricarsi e la connessione con la SMU è stata stabilita
	//Da questo momento in poi, l'oggetto globale rhea è disponibile
	
	
	//OPZIONALE
	//implementare l'handler che scatta quando la disponibilità delle selezioni cambia
	rhea.onEvent_selectionAvailabilityUpdated = function () 
	{
		/*
		var nSelection = rhea.selection_getCount();			//recupera il numero di selezioni disponibili (vedi bin/RheaMedia20/template/nestle-2.0-template-001/gui/web/js/dev/rheaSelection.js)
		for (var i=0; i<nSelection; i++)
		{
			var sel = rhea.selection_getBySelNumber(i);
			if (sel.enabled)
				...
			else
				...
		}
		*/
	}

	//OPZIONALE
	//implementare l'handler che scatta quando lo stato della CPU cambia (READY, ERROR, CLEANING....)
	//Vedi anche bin/RheaMedia20/template/nestle-2.0-template-001/gui/web/js/dev/rhea.js
	rhea.onEvent_cpuStatus = function (statusID, statusStr, flag16)
	{
		console.log ("onEvent_cpuStatus[" +statusID +"][" +statusStr +"][" +flag16 +"]");
	}
	
	//OPZIONALE
	//implementare l'handler che scatta quando il messaggio di CPU cambia
	rhea.onEvent_cpuMessage = function(msg, importanceLevel)
	{
		console.log ("onEvent_cpuMessage[" +msg +"]");
	}
	
	//OPZIONALE
	//implementare l'handler che scatta quando la CPU da inizio ad una selezione
	rhea.onEvent_selectionReqStatus = function (status)
	{
		//status=1 => wait
		//status=2 => running
		//status=3 => finished KO
		//status=4 => finished OK
		//status=5 => running, stop btn can be shown
		console.log ("onEvent_selectionReqStatus[" +status +"]");
		switch (status)
		{
			case 1:
			case 2:
			case 5:
				showPleaseWait();
				break;
				
			default:
				hidePleaseWait();
				break;
		}
	}
}

/****************************************************
 * mostra a video la rotellina di "attendere prego" e nasconde i pulsanti
 */
function showPleaseWait()
{
	rheaHideElem (rheaGetElemByID("divBottoniera"));
	rheaShowElem (rheaGetElemByID("divPleaseWait"));
}

/****************************************************
 * nasconde la rotellina di "attendere prego" e visualizza i pulsanti
 */
function hidePleaseWait()
{
	rheaShowElem (rheaGetElemByID("divBottoniera"));
	rheaHideElem (rheaGetElemByID("divPleaseWait"));
}

/****************************************************
 * 	chiede a SMU di avviare la selezione numero [iSel]
 *	SMU non risponde direttamente a questo comando, ma invierà una serie di notifiche spontanee che 
 *	riporteranno lo stato di avanzamento della selezione.
 *	Queste notifioche spontanee sono gestite da questa GUI nell'handler "rhea.onEvent_selectionReqStatus" definito nella funzione onRheaBootstrapFinished() qualche riga sopra.
 * 	L'handler in questione si limita a stampre su console le notifiche che riceve
 */
function startSelection (iSel)
{
	rhea.selection_start(iSel);
}

/****************************************************
 * 	Invia a SMU il comando ajax "getCPUStrModelAndVer".
 *	La risposta attesa di SMU è una stringa con lòa versione di CPU ed il modello di macchina
 */
function getCPUModelAndVer()
{
	//nasconde i bottoni e mostra la rotellina di "attendere prego"
	showPleaseWait();
	
	//invia il comando a SMU
	rhea.ajax ("getCPUStrModelAndVer", "").then( function(result)
	{
		//qui siamo nel caso in cui SMU ha risposto al nostro comando.
		//In [result] abbiamo la stringa con la risposta
		
		//nascondiamo la rotellina "attendere prego" e mostriamo nuovamente i bottoni
		hidePleaseWait();
		
		//stampiamo a video la risposta ricevuta da SMU
		alert (result);
	})
	.catch( function(result)
	{
		//qui siamo nel caso in cui SMU non ha risposto al nostro comando, oppure la richiesta è andata in timeout (ie: SMU non ha risposto entro 4 secondi)
		
		//nascondiamo la rotellina "attendere prego" e mostriamo nuovamente i bottoni
		hidePleaseWait();
		
		//stampiamo a video un messaggio di errore ed un eventuale possibile indizio sulla causa del problema
		alert ("ERRORE: " +result);
	});
}

/****************************************************
 *	Questa funzione invia il nuovo comando "startErogBicchiere" tramite rhea.ajax
 */
function startErogazioneBicchiere()
{
	//nasconde i bottoni e mostra la rotellina di "attendere prego"
	showPleaseWait();
	
	
	//invia il comando "startErogBicchiere".
	//La risposta è asincrona il che vuol dire che potrebbero passare anche dei secondi prima che uno dei 2 handler sottostanti venga invocato
	rhea.ajax ("startErogBicchiere", "").then( function(result)
	{
		//qui siamo nel caso in cui SMU ha risposto al nostro comando.
		//In [result] abbiamo la stringa con la risposta che, in questo caso, sara "OK" se la CPU ha avviato l'erogazione bicchiere, "KO" in caso contrario
		
		//nascondiamo la rotellina "attendere prego" e mostriamo nuovamente i bottoni
		hidePleaseWait();
		
		//se CPU ha detto "OK", avvisiamo con un messaggio a video e iniziamo a "pollare" la CPU per verificare lo stato dell'erogazione
		//PS: 	questa seconda parte relativa al polling dello stato erogazione non è implementata nel codice tutorial, lo si lascia come esercizio per il lettore.
		//		Tuttavia, nel paragrafo 5.2 è stato suggerito il formato di un ipotetico comando P 0x25 da utilizzarsi per implementare questa funzionalità
		if (result == "OK")
		{
			alert ("Erogazione bicchiere in corso");
			queryStatusErgazioneBicchiere();
		}
		else
		{
			//CPU ha risposta "KO", informiamo della cosa l'utente e terminiano
			alert ("Impossibile inziare l'erogazione del bicchiere");
		}
	})
	.catch( function(result)
	{
		//nascondiamo la rotellina "attendere prego" e mostriamo nuovamente i bottoni
		hidePleaseWait();
		
		//SMU non ha risposto, oppure la richiesta è andata in timeout.
		//Avvisiamo l'utente e terminiamo
		alert ("TIMEOUT durante 'startErogazioneBicchiere': Impossibile inziare l'erogazione del bicchiere. [" +result +"]");
	});
}


/****************************************************
 * 	NB: questa parte di codice è destinata a FALLIRE fino a che il comando "queryStatoErogBicchiere" non viene implementato in SMU.
 *	Al momento infatti, il codice tutorial-01 non prevede il comando "queryStatoErogBicchiere" e quindi la richiesta fallirà il 100% delle volte
 *
 *	Questa funzione ha lo scopo di "pollare" SMU ogni 1000ms per conoscere lo stato dell'erogazione del bicchiere.
 *	Viene chiamata inzialmente a seguito di una risposta "OK" da parte di SMU al comando "startErogBicchiere".
 *	Successivamente, questa funzione si "auto chiama" ogni 1000ms
 */
function queryStatusErgazioneBicchiere()
{
	//invia a SMU il comando "queryStatoErogBicchiere"
	rhea.ajax ("queryStatoErogBicchiere", "").then( function(result)
	{
		//SMU ha risposto, dentro result abbiamo lo stato di erogazione del bicchiere riportato
		//da CPU (NB: questo è tutto codice IPOTETICO dato che l'implementazione del comando
		//al momento non esiste in SMU)

		switch (parseInt(result))
		{
		case 0: //waiting
			//SMU ci informa che è ancora impegnata nell'erogazione del bicchiere, per cui noi
			//scheduliamo un nuovo polling fra 1000ms
			setTimeout (queryStatusErgazioneBicchiere, 1000);
			break;
			
		case 1: //finished OK
			//SMU ci comunica che l'erogazione bicchiere è terminata con successo.
			//Informiamo l'utente della cosa e terminiamo
			alert ("Bicchiere erogato");
			break;

		case 2: //finished KO
			//SMU ci comunica che l'erogazione bicchiere è fallita.
			//Informiamo l'utente della cosa e terminiamo
			alert ("Bicchiere NON erogato");
			break;
		}
	})
	.catch( function(result)
	{
		//SMU non ha risposto, oppure la richiesta è andata in timeout.
		//Avvisiamo l'utente e terminiamo
		alert ("TIMEOUT durante 'queryStatusErgazioneBicchiere': [" +result +"]");
	});	

}

</script>
</html>


